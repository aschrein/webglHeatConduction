<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
	<head>
		<title>TODO supply a title</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<script src="http://code.jquery.com/jquery-1.11.3.js"></script>
		<script id="fill_frag" type="x-shader/x-fragment">
			precision highp float;
			varying vec2 uv;
			void main()
			{
			float l = length( uv - 0.5 ) * 2.0;
			float x = 10.0 * ( uv.y * uv.x - 0.5 );
			gl_FragColor = vec4( 1000.0 * exp( -pow( abs( x ) , 2.0 ) ) , 0.0 , 0.0 , 1.0 );
			}
		</script>
		<script id="border_frag" type="x-shader/x-fragment">
			precision highp float;
			uniform sampler2D texture;
			uniform vec2 viewport_size;
			varying vec2 uv;
			void main()
			{
				vec2 border_width = vec2( 1.0 ) / viewport_size;
				bool b = 0.5 - abs( uv.x - 0.5 ) < border_width.x || 0.5 - abs( uv.y - 0.5 ) < border_width.y;
				if( b )
				{
					gl_FragColor = vec4( 0.0 , 0.0 , 0.0 , 1.0 );
				} else
				{
					gl_FragColor = texture2D( texture , uv );
				}
			}
		</script>
		<script id="proc_frag" type="x-shader/x-fragment">
			precision highp float;
			uniform vec2 viewport_size;
			uniform float dt;
			uniform sampler2D texture;
			vec2 getUV( vec2 p )
			{
				return p / viewport_size;
			}
			vec2 getPos( vec2 uv )
			{
				return uv * viewport_size;
			}
			float getT( vec2 p )
			{
				return texture2D( texture , getUV( p ) ).x;
			}
			vec2 gradT( vec2 p )
			{
				return vec2( getT( p + vec2( 1.0 , 0.0 ) ) - getT( p + vec2( -1.0 , 0.0 ) ) ,
					getT( p + vec2( 0.0 , 1.0 ) ) - getT( p + vec2( 0.0 , -1.0 ) ) );
			}
			float laplT( vec2 p )
			{
				return getT( p + vec2( 1.0 , 0.0 ) ) + getT( p + vec2( -1.0 , 0.0 ) )
				+ getT( p + vec2( 0.0 , 1.0 ) ) + getT( p + vec2( 0.0 , -1.0 ) ) - getT( p ) * 4.0;
			}
			varying vec2 uv;
			void main()
			{
				gl_FragColor = vec4( laplT( getPos( uv ) ) * 10.1 , vec3( 0.0 ) ) * dt +
				texture2D( texture , uv );
			}
		</script>
		<script id="copy_frag" type="x-shader/x-fragment">
			precision highp float;
			uniform sampler2D texture;
			varying vec2 uv;
			vec3 color( float x )
			{
				float t = x * 1.0e-3;
				return mix( vec3( 0.0 , 0.1 , 0.5 )
				, mix( vec3( 0.8 , 0.2 , 0.0 )
					, mix( vec3( 0.99 , 0.6 , 0.0 )
						, vec3( 1.0 , 1.0 , 1.0 )
						, clamp( 4.0 * t - 3.0 , 0.0 , 1.0 ) )
					, clamp( 2.0 * t - 1.0 , 0.0 , 1.0 ) )
				, clamp( 2.0 * t , 0.0 , 1.0 ) );
			}
			void main()
			{
				gl_FragColor = vec4( color( texture2D( texture , uv ).x ) , 1.0 );
			}
		</script>
		<script id="simple_vert" type="x-shader/x-vertex">
			attribute vec3 vertex_pos;
			varying vec2 uv;
			void main()
			{
				uv = 0.5 * vertex_pos.xy + 0.5;
				gl_Position = vec4( vertex_pos , 1.0 );
			}
		</script>
		<script id="point_frag" type="x-shader/x-fragment">
			precision highp float;
			varying vec2 uv;
			void main()
			{
				gl_FragColor = length( uv - 0.5 ) < 0.5 ? vec4( vec3( 0.0 ) , 1.0 ) : vec4( 0.0 , 0.0 , 0.0 , 0.0 );
			}
		</script>
		<script id="point_vert" type="x-shader/x-vertex">
			attribute vec3 vertex_pos;
			uniform vec2 pos;
			uniform vec2 size;
			varying vec2 uv;
			void main()
			{
				uv = 0.5 * vertex_pos.xy + 0.5;
				gl_Position = vec4( pos + size * vertex_pos.xy , -0.01 , 1.0 );
			}
		</script>
		<script>
var gl;
function initGL()
{
	try
	{
		var canvas = document.getElementById( "main_canvas" );
		var temperature_point = { x : 0.5 , y : 0.5 };
		var temperature_label = document.getElementById( "temperature_label" );
		temperature_label.style.position = 'absolute';
		gl = canvas.getContext( "experimental-webgl" );
		gl.getExtension( 'OES_texture_float' );
		gl.getExtension( 'OES_texture_float_linear' );
		gl.viewportWidth = canvas.width;
		gl.viewportHeight = canvas.height;
		$( '#main_canvas' ).mousedown( function( e )
		{
			var mouseX = e.pageX - this.offsetLeft;
			var mouseY = e.pageY - this.offsetTop;
			if( mouseX < gl.viewportWidth && mouseY < gl.viewportHeight )
			{
				temperature_point.x = mouseX / gl.viewportWidth;
				temperature_point.y = 1.0 - mouseY / gl.viewportHeight;
				temperature_label.style.left = mouseX + 'px';
				temperature_label.style.top = ( mouseY + 16 ) + 'px';
			}
		} );
		gl.cur_shader = null;
		gl.cur_buffer = null;
		gl.bindTarget = function( buffer )
		{
			//if( gl.cur_buffer != buffer )
			{
				gl.cur_buffer = buffer;
				if( !buffer )
				{
					gl.bindFramebuffer( gl.FRAMEBUFFER , null );
					gl.viewport( 0 , 0 , gl.viewportWidth , gl.viewportHeight );
				} else
				{
					gl.bindFramebuffer( gl.FRAMEBUFFER , buffer.id );
					gl.viewport( 0 , 0 , gl.cur_buffer.width , gl.cur_buffer.height );
				}
			}
		};
		gl.clear_color = { r : 0.0 , g : 0.0 , b : 0.0 };
		gl.clearTarget = function()
		{
			gl.clearColor( gl.clear_color.r , gl.clear_color.g , gl.clear_color.b , 1.0 );
			gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
		};
		gl.bindShader = function( shader )
		{
			//if( out.cur_shader !== shader )
			{
				gl.texture_samplers_count = 0;
				gl.cur_shader = shader;
				gl.useProgram( shader );
				shader.resetSamplers();
			}
		};

		var fbuf = [ genFrameBuffer( 128 , 128 , null ) , genFrameBuffer( 128 , 128 , null ) ];
		var fill_shader = genShader( "fill_frag" , "simple_vert" );
		var proc_shader = genShader( "proc_frag" , "simple_vert" );
		var border_shader = genShader( "border_frag" , "simple_vert" );
		var copy_shader = genShader( "copy_frag" , "simple_vert" );
		var point_shader = genShader( "point_frag" , "point_vert" );
		var fullscreen_quad = genFullScreenQuad();
		var last_time = new Date().getTime() * 1.0e-3;
		var frame_counter = 0;
		var proc_buf = 0;
		var tgr_buf = 1;
		var swapBuf = function()
		{
			var tmp = tgr_buf;
			tgr_buf = proc_buf;
			proc_buf = tmp;
		};
		gl.disable( gl.DEPTH_TEST );
		gl.disable( gl.BLEND );
		gl.bindTarget( fbuf[ tgr_buf ] );
		gl.clearTarget();
		{
			gl.bindTarget( fbuf[ proc_buf ] );
			gl.clearTarget();
			gl.bindShader( fill_shader );
			fullscreen_quad.draw();
		}
		var last_dt = 0.016;
		var dt_sum = 0.0;
		
		setInterval( function()
		{
			gl.disable( gl.BLEND );
			{
				gl.bindTarget( fbuf[ tgr_buf ] );
				gl.bindShader( proc_shader );
				gl.uniform1f( proc_shader.getUniformLoc( "dt" ) , last_dt );
				gl.uniform2f( proc_shader.getUniformLoc( "viewport_size" ) , fbuf[ tgr_buf ].width , fbuf[ tgr_buf ].height );
				proc_shader.bindTexture( fbuf[ proc_buf ].texid , "texture" );
				fullscreen_quad.draw();
				swapBuf();
			}
			{
				gl.bindTarget( fbuf[ tgr_buf ] );
				gl.bindShader( border_shader );
				gl.uniform2f( border_shader.getUniformLoc( "viewport_size" ) , fbuf[ tgr_buf ].width , fbuf[ tgr_buf ].height );
				border_shader.bindTexture( fbuf[ proc_buf ].texid , "texture" );
				fullscreen_quad.draw();
				swapBuf();
			}
			var pixels = new Float32Array( 4 );
			gl.readPixels( temperature_point.x * fbuf[ proc_buf ].width , temperature_point.y * fbuf[ proc_buf ].height , 1 , 1 , gl.RGBA , gl.FLOAT , pixels );
			temperature_label.innerHTML = pixels[ 0 ];
			//console.log( pixels[ 0 ] );
			gl.bindTarget( null );
			gl.clearTarget();
			gl.bindShader( copy_shader );
			copy_shader.bindTexture( fbuf[ proc_buf ].texid , 0 );
			fullscreen_quad.draw();
			
			
			gl.enable( gl.BLEND );
			gl.blendFunc( gl.SRC_ALPHA , gl.ONE_MINUS_SRC_ALPHA );
			gl.bindShader( point_shader );
			gl.uniform2f( point_shader.getUniformLoc( "size" ) , 0.01 , 0.01 );
			gl.uniform2f( point_shader.getUniformLoc( "pos" ) , 2.0 * temperature_point.x - 1 , 2.0 * temperature_point.y - 1 );
			fullscreen_quad.draw();
			
			var cur_time = new Date().getTime() * 1.0e-3;
			last_dt = ( cur_time - last_time );
			last_time = cur_time;
			dt_sum += last_dt;
			if( frame_counter === 100 )
			{
				//console.log( dt_sum * 1.0e1 );
				dt_sum = 0.0;
				frame_counter = 1;
			}
			frame_counter++;
		} , 16 );
	} catch( e )
	{
		alert( e );
	}
	if( !gl )
	{
		alert( "Could not initialise WebGL" );
	}
}
function genShader( fragment_id , vertex_id ){
	function getSubShader( gl , id ){
		var shaderScript = document.getElementById( id );
		if( !shaderScript ){
			return null;
		}
		var str = "";
		var k = shaderScript.firstChild;
		while( k ){
			if( k.nodeType === 3 ){
				str += k.textContent;
			}
			k = k.nextSibling;
		}
		var shader;
		if( shaderScript.type === "x-shader/x-fragment" ){
			shader = gl.createShader( gl.FRAGMENT_SHADER );
		} else if( shaderScript.type === "x-shader/x-vertex" ){
			shader = gl.createShader( gl.VERTEX_SHADER );
		} else{
			return null;
		}
		gl.shaderSource( shader , str );
		gl.compileShader( shader );

		if( !gl.getShaderParameter( shader , gl.COMPILE_STATUS ) ){
			alert( gl.getShaderInfoLog( shader ) );
			return null;
		}
		return shader;
	}
	var fragmentShader = getSubShader( gl , fragment_id );
	var vertexShader = getSubShader( gl , vertex_id );

	var out = gl.createProgram();
	gl.attachShader( out , vertexShader );
	gl.attachShader( out , fragmentShader );
	gl.linkProgram( out );

	if( !gl.getProgramParameter( out , gl.LINK_STATUS ) ){
		alert( "Could not initialise shaders:" + fragment_id + ", " + vertex_id );
	}
	out.texture_samplers_count = 0;
	out.resetSamplers = function()
	{
		out.texture_samplers_count = 0;
	};
	out.uniformMap = { };
	out.getUniformLoc = function( name )
	{
		if( !out.uniformMap[ name ] )
		{
			out.uniformMap[ name ] = gl.getUniformLocation( out , name );
		}
		return out.uniformMap[ name ];
	};
	out.bindTexture = function( id , name )
	{
		if( !out.uniformMap[ name ] )
		{
			out.uniformMap[ name ] = gl.getUniformLocation( out , name );
		}
		gl.activeTexture( gl.TEXTURE0 + out.texture_samplers_count );
		gl.bindTexture( gl.TEXTURE_2D , id );
		gl.uniform1i( out.uniformMap[ name ] , out.texture_samplers_count );
		out.texture_samplers_count += 1;
	};
	gl.useProgram( out );
	return out;
	//shaderProgram.vertexPositionAttribute = gl.getAttribLocation( shaderProgram , "aVertexPosition" );
	//gl.enableVertexAttribArray( shaderProgram.vertexPositionAttribute );
}
function genFrameBuffer( width , height , depth )
{
	var out = { };
	out.width = width;
	out.height = height;
	out.id = gl.createFramebuffer();
	gl.bindFramebuffer( gl.FRAMEBUFFER , out.id );
	out.texid = gl.createTexture();
	gl.bindTexture( gl.TEXTURE_2D , out.texid );
	gl.texImage2D( gl.TEXTURE_2D , 0 , gl.RGBA , width , height , 0 , gl.RGBA , gl.FLOAT , null );
	gl.texParameteri( gl.TEXTURE_2D , gl.TEXTURE_MAG_FILTER , gl.LINEAR );
	gl.texParameteri( gl.TEXTURE_2D , gl.TEXTURE_MIN_FILTER , gl.LINEAR );
	gl.texParameteri( gl.TEXTURE_2D , gl.TEXTURE_WRAP_S , gl.CLAMP_TO_EDGE );
	gl.texParameteri( gl.TEXTURE_2D , gl.TEXTURE_WRAP_T , gl.CLAMP_TO_EDGE );
	//gl.generateMipmap( gl.TEXTURE_2D );
	gl.framebufferTexture2D( gl.FRAMEBUFFER , gl.COLOR_ATTACHMENT0 , gl.TEXTURE_2D , out.texid , 0 );
	out.depthid = null;
	if( depth )
	{
		out.depthid = gl.createRenderbuffer();
		gl.bindRenderbuffer( gl.RENDERBUFFER , out.depthid );
		gl.renderbufferStorage( gl.RENDERBUFFER , gl.DEPTH_COMPONENT16 , width , height );
		gl.framebufferRenderbuffer( gl.FRAMEBUFFER , gl.DEPTH_ATTACHMENT , gl.RENDERBUFFER , out.depthid );
		gl.bindRenderbuffer( gl.RENDERBUFFER , null );
	}
	gl.bindTexture( gl.TEXTURE_2D , null );
	gl.bindFramebuffer( gl.FRAMEBUFFER , null );
	return out;
}
function genFullScreenQuad()
{
	var out = { };
	out.bufid = gl.createBuffer();
	gl.bindBuffer( gl.ARRAY_BUFFER , out.bufid );
	var vertices = [
		1.0 , 1.0 , 0.0 ,
		-1.0 , 1.0 , 0.0 ,
		1.0 , -1.0 , 0.0 ,
		-1.0 , -1.0 , 0.0
	];
	gl.bufferData( gl.ARRAY_BUFFER , new Float32Array( vertices ) , gl.STATIC_DRAW );
	out.draw = function()
	{
		gl.bindBuffer( gl.ARRAY_BUFFER , out.bufid );
		gl.enableVertexAttribArray( 0 );
		gl.vertexAttribPointer( 0 , 3 , gl.FLOAT , false , 0 , 0 );
		gl.drawArrays( gl.TRIANGLE_STRIP , 0 , 4 );
	};
	return out;
}
		</script>
	</head>
	<body onload="initGL();">
		<canvas id="main_canvas" width="512" height="512" ></canvas>
		<div id="temperature_label"></div>
	</body>
</html>
